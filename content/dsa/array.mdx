---
title: "Array"
publishedAt: "2025-09-22"
---

An array is a contiguous block in RAM. For example `[1, 3, 5]` (integers), each takes 4 bytes (32 bits), so addresses might be `$0`, `$4`, `$8`. For chars like `['A', 'B', 'C']`, its 1 byte each: `$0`, `$1`, `$2`. The key is everything is next to each other, and we access via indexes starting at 0.

Note that integers are often 32-bit: 1 is 31 zeros and a 1 at the end in binary. Arrays are simple, their memory layout matches how I think of them in code.

### Types of Arrays

There are basically two types of arrays:

- **Static Array**: In this type of array, memory is allocated at compile time with a fixed size. We cannot alter or update the size of the array once its created, that's the big limitation when compared to dynamic ones.

- **Dynamic Array**: In this type of array, memory is allocated at run time without a fixed size. If a user wants to declare a random size for an array we won't use a static one, instead, a dynamic array comes in handy. It's used to specify (and change) the size during the run time of any program.

*Note: Python and JS/TS default to dynamic arrays, unlike C/C++/Java.*

### Static Arrays

#### Reading

Reading is fast, O(1) because RAM is random access (can jump to any address instantly). Index maps directly to the memory address.

Looping through is O(n), obviously, since you hit each element.

::: code-group labels=[Python, TypeScript]
```python
my_array = [0] * 3
my_array[0] = 1
my_array[1] = 3
my_array[2] = 5

# Read index 0
print(my_array[0])  # 1

# Loop
for value in my_array:
    print(value)  # 1 3 5
```

```typescript
const myArray: number[] = new Array(3).fill(0);
myArray[0] = 1;
myArray[1] = 3;
myArray[2] = 5;

console.log(myArray[0]); // 1

for (const value of myArray) {
    console.log(value) // 1 3 5
}

```
:::

#### Writing

If you want to overwrite an existing spot, just place the new value at the index, O(1).

Adding to the end (if there's space)? Also O(1): Track a `count` var, write there, increment.

Removing? Overwrite with None/null and decrement count, still O(1).

#### Insert/Remove in the Middle

This is where it hurts: O(n) worst case (on average) because you have to shift elements to keep contiguity.
- **Insert**: Slide everything right from a spot, then drop in the new value.
- **Remove**: Slide left to fill the gap.

**Example**: Inserting at the start (worst shift).

::: code-group labels=[Python, Typescript]
```python
my_array = [5, 6, 0]
for i in range(len(my_array) - 1, 0, -1): # Shift right
    my_array[i] = my_array[i - 1];
my_array[0] = 4
print(my_array) # [4, 5, 6]
```

```typescript
const myArray: number[] = [5, 6, 0];
for (let i = myArray.length - 1; i > 0; i--) { // Shift right
    myArray[i] = myArray[i - 1];
}
myArray[0] = 4;
console.log(myArray) // [4, 5, 6]
```
:::

#### Trade offs

Good for fast access if size known. Bad for frequent inserts/removes in middle or growing in size. In Python/TS, arrays are dynamic by default, so I rarely hit this, but good to know for lower-level stuff.

### Implementation

For the full implementation including pytest tests, check out my [GitHub repo](https://github.com/zdravkodanailov7/dsa/blob/main/python/static_array.py). All tests pass, give it a clone and pytest static_array.py!
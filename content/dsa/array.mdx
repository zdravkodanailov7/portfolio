---
title: "Array"
publishedAt: "2025-09-30"
---

An array is a contiguous block in RAM. For example `[1, 3, 5]` (integers), each takes 4 bytes (32 bits), so addresses might be `$0`, `$4`, `$8`. For chars like `['A', 'B', 'C']`, its 1 byte each: `$0`, `$1`, `$2`. The key is everything is next to each other, and we access via indexes starting at 0.

Note that integers are often 32-bit: 1 is 31 zeros and a 1 at the end in binary. Arrays are simple, their memory layout matches how I think of them in code.

### Types of Arrays

There are basically two types of arrays:

- **Static Array**: In this type of array, memory is allocated at compile time with a fixed size. We cannot alter or update the size of the array once its created, that's the big limitation when compared to dynamic ones.

- **Dynamic Array**: In this type of array, memory is allocated at run time without a fixed size. If a user wants to declare a random size for an array we won't use a static one, instead, a dynamic array comes in handy. It's used to specify (and change) the size during the run time of any program.

*Note: Python and JS/TS default to dynamic arrays, unlike C/C++/Java.*

### Static Arrays

#### Reading

Reading is fast, O(1) because RAM is random access (can jump to any address instantly). Index maps directly to the memory address.

Looping through is O(n), obviously, since you hit each element.

::: code-group labels=[Python, TypeScript]
```python
my_array = [0] * 3
my_array[0] = 1
my_array[1] = 3
my_array[2] = 5

# Read index 0
print(my_array[0])  # 1

# Loop
for value in my_array:
    print(value)  # 1 3 5
```

```typescript
const myArray: number[] = new Array(3).fill(0);
myArray[0] = 1;
myArray[1] = 3;
myArray[2] = 5;

console.log(myArray[0]); // 1

for (const value of myArray) {
    console.log(value) // 1 3 5
}

```
:::

#### Writing

If you want to overwrite an existing spot, just place the new value at the index, O(1).

Adding to the end (if there's space)? Also O(1): Track a `count` var, write there, increment.

Removing? Overwrite with None/null and decrement count, still O(1).

#### Insert/Remove in the Middle

This is where it hurts: O(n) worst case (on average) because you have to shift elements to keep contiguity.
- **Insert**: Slide everything right from a spot, then drop in the new value.
- **Remove**: Slide left to fill the gap.

**Example**: Inserting at the start (worst shift).

::: code-group labels=[Python, Typescript]
```python
my_array = [5, 6, 0]
for i in range(len(my_array) - 1, 0, -1): # Shift right
    my_array[i] = my_array[i - 1];
my_array[0] = 4
print(my_array) # [4, 5, 6]
```

```typescript
const myArray: number[] = [5, 6, 0];
for (let i = myArray.length - 1; i > 0; i--) { // Shift right
    myArray[i] = myArray[i - 1];
}
myArray[0] = 4;
console.log(myArray) // [4, 5, 6]
```
:::

#### Trade offs

Good for fast access if size known. Bad for frequent inserts/removes in middle or growing in size. In Python/TS, arrays are dynamic by default, so I rarely hit this, but good to know for lower-level stuff.

### Implementation

Full code with tests in the [git repo](https://github.com/zdravkodanailov7/dsa).

::: code-group labels=[Python, Typescript]
```python
class StaticArray:
    def __init__(self, capacity):
        self._array = [0] * capacity
        self._length = 0
        self._capacity = capacity
    
    def insert_end(self, n):
        if self._length < self._capacity:
            self._array[self._length] = n
            self._length += 1
            return True
        return False # Full, no insertion

    def remove_end(self):
        if self._length > 0:
            self._array[self._length - 1] = 0
            self._length -= 1
            return True
        return False # Empty, no removal

    def insert_middle(self, i, n):
        if i < 0 or i > self._length or self._length >= self._capacity:
            return False # Invalid index or full
        # Shift starting from the end to i
        for index in range(self._length - 1, i - 1, -1):
            self._array[index + 1] = self._array[index]
        # Insert at i
        self._array[i] = n
        self._length += 1
        return True

    def remove_middle(self, i):
        if i < 0 or i >= self._length:
            return False # Invalid index
        # Shift starting from i + 1 to the end
        for index in range(i + 1, self._length):
            self._array[index - 1] = self._array[index]
        # No need to "remove" self._array[i], since we shifted
        self._array[self._length - 1] = 0 # Optional: clear the last spot
        self._length -= 1
        return True

    def print_array(self):
        for i in range(self._capacity):
            print(self._array[i])
    
    def is_full(self):
        return self._length == self._capacity

    def is_empty(self):
        return self._length == 0

    def get_length(self):
        return self._length

    def get_capacity(self):
        return self._capacity
```
```typescript
export class StaticArray {
    private _array: number[];
    private _length: number;
    private _capacity: number;

    constructor(capacity: number) {
        this._array = new Array(capacity).fill(0);
        this._length = 0;
        this._capacity = capacity;
    }

    insertEnd(n: number): boolean {
        if (this._length < this._capacity) {
            this._array[this._length] = n;
            this._length += 1;
            return true;
        }
        return false; // Full, no insertion
    }

    removeEnd(): boolean {
        if (this._length > 0) {
            this._array[this._length - 1] = 0;
            this._length -= 1;
            return true;
        }
        return false; // Empty, no removal
    }

    insertMiddle(i: number, n: number): boolean {
        if (i < 0 || i > this._length || this._length >= this._capacity) {
            return false; // Invalid index or full
        }
        // Shift starting from the end to i
        for (let index = this._length - 1; index >= i; index--) {
            this._array[index + 1] = this._array[index];
        }
        // Insert at i
        this._array[i] = n;
        this._length += 1;
        return true;
    }

    removeMiddle(i: number): boolean {
        if (i < 0 || i >= this._length) {
            return false; // Invalid index
        }
        // Shift starting from i + 1 to the end
        for (let index = i + 1; index < this._length; index++) {
            this._array[index - 1] = this._array[index];
        }
        // No need to "remove" this._array[i], since we shifted
        this._array[this._length - 1] = 0; // Optional: clear the last spot
        this._length -= 1;
        return true;
    }

    printArray(): void {
        for (let i = 0; i < this._capacity; i++) {
            console.log(this._array[i]);
        }
    }

    isFull(): boolean {
        return this._length === this._capacity;
    }

    isEmpty(): boolean {
        return this._length === 0;
    }

    getLength(): number {
        return this._length;
    }

    getCapacity(): number {
        return this._capacity;
    }
}
```
:::